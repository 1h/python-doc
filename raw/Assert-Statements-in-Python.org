#+TITLE: Assert-Statements-in-Python
#+AUTHOR: lujun9972
#+TAGS: raw
#+DATE: [2017-03-14 二 02:39]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

#+URL: https://dbader.org/blog/python-assert-tutorial

如何利用断言自动探测Python程序中的错误使之更可靠且易于调试.

[[https://dbader.org/blog/figures/python-assert.png]]

* 什么时断言 & 断言擅长什么?

Python的 =assert= 语句可以用于调试. 它会测试一个条件,若这个条件为真,则它什么也不做,你的程序照常往下执行.
但若条件为假,则它会抛出一个 =AssertionError= 异常,该异常甚至还能包括一个错误信息.

=assertions= 的正确使用方法是用它来通知开发者程序中出现了无法回复的异常. 
你不能用它来处理类似"文件没找到"这类可以预见的错误,因为用户可以采取行动修正这一错误,然后重试.

另一种看法是把 =assertions= 看成是程序的内部检查工具.
它标注某些情况是不可能在代码中出现的. 如果真的出现了其中的情况,那表示程序中肯定有bug.

若你的程序中没有bug, 就不会触发这些条件. 但如果真的触发了这些条件,那么程序就会崩溃,并显示一条断言错误信息告诉你是触发了哪一条"不该出现的"条件.
这有利于追踪和修复bug.

总结起来就是: Python的 =assert= 是一种调试的工具而不适于用来处理运行时错误的.
使用断言是为了让开发者快速找到bug产生的根源.
应该要做到只有当你的程序中出现bug时才能抛出断言错误.

* Python中的Assert — 举个例子

下面是一个简单的例子,展示一下断言应该怎么用.
我尽量让这个例子更实际一点.

假设你在用Python搭建一个在线商场. 你需要为它添加一项折扣券的功能因此写了下面这个 =apply_discount= 功能:

#+BEGIN_SRC python
  def apply_discount(product, discount):
      price = int(product['price'] * (1.0 - discount))
      assert 0 <= price <= product['price']
      return price
#+END_SRC

注意到了那个 =assert= 语句了么? 它会保证,不管怎么样,打折后的价格都不会低于0元,也不会高于原价.

让我们用各种折扣来调用该函数,确保该函数能如我们所愿那边地正常工作.

#+BEGIN_SRC python
  #
  # Our example product: Nice shoes for $149.00
  #
  >>> shoes = {'name': 'Fancy Shoes', 'price': 14900}

  #
  # 25% off -> $111.75
  #
  >>> apply_discount(shoes, 0.25)
  11175
#+END_SRC

不错,挺正常的. 现在再试试其他非法的折扣:

#+BEGIN_SRC python
  #
  # A "200% off" discount:
  #
  >>> apply_discount(shoes, 2.0)
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
      apply_discount(prod, 2.0)
    File "<input>", line 4, in apply_discount
      assert 0 <= price <= product['price']
  AssertionError

  #
  # A "-30% off" discount:
  #
  >>> apply_discount(shoes, -0.3)
  Traceback (most recent call last):
    File "<input>", line 1, in <module>
      apply_discount(prod, -0.3)
    File "<input>", line 4, in apply_discount
      assert 0 <= price <= product['price']
  AssertionError
#+END_SRC

如你所见,当传入一个非法的折扣时会引发 =AssertionError= 异常,并指出异常的行以及不匹配的断言条件.
当我们在测试在线商场时,若出现了这种错误,通过查看 traceback 可以很方便地找出错误原因.

这就是断言的威力.

* Python’s Assert Syntax

开始使用某项语言特性前最好先了解它是如何实现的. 下面我们就来看一下 [[https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement][Python文档中assert语句的语法是怎样的]]:

#+BEGIN_SRC python
  assert_stmt ::= "assert" expression1 ["," expression2]
#+END_SRC

其中 =expression1= 就是我们要测试的条件, 而可选的 =expression2= 是断言失败时要显示的错误信息.

在执行期间,Python解释器会将每个 =assert= 语句都转换成类似下面这样:

#+BEGIN_SRC python
  if __debug__:
      if not expression1:
          raise AssertionError(expression2)
#+END_SRC

你也可以通过 =expression2= 传递一个可选的错误信息, 当触发 =AssertionError= 异常时, 该错误信息也会一同在 traceback 中显示出来.
它可以进一步简化调试. 举个例子,我曾见过这样的代码:

#+BEGIN_SRC python
  if cond == 'x':
      do_x()
  elif cond == 'y':
      do_y()
  else:
      assert False, ("This should never happen, but it does occasionally. "
                     "We're currently trying to figure out why. "
                     "Email dbader if you encounter this in the wild.")
#+END_SRC

这段代码丑吗? 是的,的确很丑. 但是当你遇见 [[https://en.wikipedia.org/wiki/Heisenbug][heisenbug-type issue]] 这样的问题时,这种技术都很有用了. 😉

* Common Pitfalls With Using Asserts in Python

Before you move on, there are two important caveats with using assertions in
Python that I’d like to call out.

The first one has to do with introducing security risks and bugs into your
applications, and the second one is about a syntax quirk that makes it easy to
write useless assertions.

This sounds (and potentially is) pretty horrible, so you might at least want
to skim these two caveats or read their summaries below.

** Caveat #1 – Don’t Use Asserts for Data Validation

*Asserts can be turned off globally in the Python interpreter. Don’t rely on assert expressions to be executed for data validation or data processing.*

The biggest caveat with using asserts in Python is that [[https://docs.python.org/3/library/constants.html#__debug__][assertions can be]]
[[https://docs.python.org/3/library/constants.html#__debug__][globally disabled]] with the -O and -OO command line switches, as well as the
PYTHONOPTIMIZE environment variable in CPython.

This turns any assert statement into a null-operation: the assertions simply
get compiled away and won’t be evaluated, which means that none of the
conditional expressions will be executed.

This is an intentional design decision used similarly by many other
programming languages. As a side-effect it becomes extremely dangerous to use
assert statements as a quick and easy way to validate input data.

Let me explain—if your program uses asserts to check if a function argument
contains a “wrong” or unexpected value this can backfire quickly and lead to
bugs or security holes.

Let’s take a look at a simple example. Imagine you’re building an online store
application with Python. Somewhere in your application code there’s a function
to delete a product as per a user’s request:

#+BEGIN_SRC python
  def delete_product(product_id, user):
      assert user.is_admin(), 'Must have admin privileges to delete'
      assert store.product_exists(product_id), 'Unknown product id'
      store.find_product(product_id).delete()
#+END_SRC

Take a close look at this function. What happens if assertions are disabled?

There are two serious issues in this three-line function example, caused by
the incorrect use of assert statements:

 1. Checking for admin privileges with an assert statement is dangerous. If
    assertions are disabled in the Python interpreter, this turns into a
    null-op. Therefore any user can now delete products. The privileges check
    doesn’t even run. This likely introduces a security problem and opens the
    door for attackers to destroy or severely damage the data in your
    customer’s or company’s online store. Not good.
 2. The product_exists() check is skipped when assertions are disabled. This
    means find_product() can now be called with invalid product ids—which
    could lead to more severe bugs depending on how our program is written. In
    the worst case this could be an avenue for someone to launch Denial of
    Service attacks against our store. If the store app crashes if we attempt
    to delete an unknown product, it might be possible for an attacker to
    bombard it with invalid delete requests and cause an outage.

How might we avoid these problems? The answer is to not use assertions to do
data validation. Instead we could do our validation with regular if-statements
and raise validation exceptions if necessary. Like so:

#+BEGIN_SRC python
  def delete_product(product_id, user):
      if not user.is_admin():
          raise AuthError('Must have admin privileges to delete')

      if not store.product_exists(product_id):
          raise ValueError('Unknown product id')

      store.find_product(product_id).delete()
#+END_SRC

This updated example also has the benefit that instead of raising unspecific
AssertionError exceptions, it now raises semantically correct exceptions like
ValueError or AuthError (which [[https://dbader.org/blog/python-custom-exceptions][we’d have to define ourselves]]).

** Caveat #2 – Asserts That Never Fail

It’s easy to accidentally write Python assert statements that always evaluate
to true. I’ve been bitten by this myself in the past. I wrote [[https://dbader.org/blog/catching-bogus-python-asserts][a longer article]]
[[https://dbader.org/blog/catching-bogus-python-asserts][about this specific issue you can check out by clicking here]].

Alternatively, here’s the executive summary:

*When you pass a tuple as the first argument in an assert statement, the assertion always evaluates as true and therefore never fails.*

For example, this assertion will never fail:

#+BEGIN_SRC python
  assert(1 == 2, 'This should fail')
#+END_SRC

This has to do with non-empty tuples always being truthy in Python. If you
pass a tuple to an assert statement it leads to the assert condition to always
be true—which in turn leads to the above assert statement being useless
because it can never fail and trigger an exception.

It’s relatively easy to accidentally write bad multi-line asserts due to this
unintuitive behavior. This quickly leads to broken test cases that give a
false sense of security in our test code. Imagine you had this assertion
somewhere in your unit test suite:

#+BEGIN_SRC python
  assert (
      counter == 10,
      'It should have counted all the items'
  )
#+END_SRC

Upon first inspection this test case looks completely fine. However, this test
case would never catch an incorrect result: it always evaluates to True,
regardless of the state of the counter variable.

Like I said, it’s rather easy to shoot yourself in the foot with this (mine
still hurts). Luckily, there are some countermeasures you can apply to prevent
this syntax quirk from causing trouble:

[[https://dbader.org/blog/catching-bogus-python-asserts][>> Read the full article on bogus assertions to get the dirty details.]]

* Python Assertions — Summary

Despite these caveats I believe that Python’s assertions are a powerful
debugging tool that’s frequently underused by Python developers.

Understanding how assertions work and when to apply them can help you write
more maintainable and easier to debug Python programs. It’s a great skill to
learn that will help bring your Python to the next level and make you a more
well-rounded Pythonista.
